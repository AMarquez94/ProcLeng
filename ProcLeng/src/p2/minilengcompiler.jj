/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;
  Ignore_case = true;}PARSER_BEGIN(minilengcompiler)package p2;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Scanner;
import p2.Constants;
import java.util.ArrayList;
import p2.Simbolo.*;

public class minilengcompiler{
	static Token ultTk;
	static Tabla_simbolos T;
	static int nivel;
  
  public static void main(String args []) throws ParseException  {
    boolean debug = false;
    boolean debugSintactico = false;
    minilengcompiler parser = null;
    T = new Tabla_simbolos();
    nivel = 0;

    Token ultTok;

    if(args.length == 0)    {    	parser = new minilengcompiler(System.in);
    	System.out.println("Leyendo de la entrada estandar...");
    }
    else if(args.length == 1)    {
      if(args[0].compareToIgnoreCase("-lex_stats") == 0)      {
		parser = new minilengcompiler(System.in);
		System.out.println("Leyendo de la entrada estandar... (Modo debug lexico)");
		debug = true;      }

      else if(args[0].compareToIgnoreCase("-syntax_stats") == 0)      {
        parser = new minilengcompiler(System.in);
        System.out.println("Leyendo de la entrada estandar... (Modo debug sintactico)");
        debugSintactico = true;
      }	  else	  {
	    try	    {			parser = new minilengcompiler(new FileInputStream(args[0]));
			System.out.println("Leyendo de fichero...");
		}
		catch(IOException e)		{
		  	System.out.println("Error:fichero no encontrado");
		  	System.exit(0);		}
	  }
    }
    else if(args.length == 2)    {
      	if(args[0].compareToIgnoreCase("-lex_stats") == 0)      	{
      	  try      	  {			parser = new minilengcompiler(new FileInputStream(args[1]));
			System.out.println("Leyendo de fichero... (Modo debug lexico)");
			debug = true;
		  }
		  catch(IOException e)
		  {
		  	System.out.println("Error: error de e/s con el fichero");
		  	System.exit(1);
		  }
      	}
      	else if(args[0].compareToIgnoreCase("-syntax_stats") == 0)      	{
      	  try
      	  {
			parser = new minilengcompiler(new FileInputStream(args[1]));
			System.out.println("Leyendo de fichero... (Modo debug sintactico)");
			debugSintactico = true;
		  }
		  catch(IOException e)
		  {
		  	System.out.println("Error: error de e/s con el fichero");
		  	System.exit(1);
		  }      	}
      	else      	{			System.out.println("Error: Argumentos inválidos");
			System.exit(1);
      	}    }
    else    {		System.out.println("Error: Argumentos inválidos");
		System.exit(1);
    }	while (true)	{	    try	    {   			if (minilengcompiler.compile() == 1)        	{     		 System.out.println("Fin.");   		     break;	        }  		}  		catch (Exception e)  		{
  		  	Scanner error = new Scanner(e.getMessage());
  		  	error.useDelimiter(",|\\.| |\"");
  		  	error.next();error.next();error.next();  		  	String tipoEncontrado = error.next();
  		  	if(tipoEncontrado.equals(""))  		  	{
				tipoEncontrado = "\" \"";
  		  	}
  		  	while(!error.hasNextInt())  		  	{				error.next();
  		  	}
  		  	int linea = error.nextInt();
  		  	while(!error.hasNextInt())
  		  	{
				error.next();
  		  	}  		  	int columna = error.nextInt();  		  	error.nextLine();error.nextLine();  		  	String mensaje = "";  		  	while(error.hasNextLine())  		  	{				mensaje = mensaje + "%n" + error.nextLine();  		  	}  		  	error.close();  		  	System.err.printf("ERROR SINTÁCTICO (<%d,%d>): se ha reconocido un %s cuando se esperaba:",linea,columna,tipoEncontrado);
  		  	System.err.printf(mensaje);    		System.exit(0);      }      catch (Error e)      {
        Scanner error = new Scanner(e.getMessage());
        error.useDelimiter(",|\\.| |\"");
        error.next();error.next();error.next();error.next();        int linea = error.nextInt();        error.next();error.next();        int columna = error.nextInt();
        error.next();error.next();error.next();error.next();
        String simbolo = error.next();
        error.close();
        System.err.printf("ERROR LÉXICO (<%d,%d>): símbolo no reconocido: <%s>%n",linea,columna,simbolo);
        System.exit(0);      }    }
    if(debug)    {
      Constants.printLexical();
          }
    else if(debugSintactico)    {
      Constants.printSyntactic();
    }  }
  private static void error_semantico(Token tk, String mensaje){
  	System.err.printf("ERROR SEMÁNTICO (<%d,%d>): " + mensaje + ": <%s>%n",tk.beginLine,tk.beginColumn,tk.image);
  }}

PARSER_END(minilengcompiler)

TOKEN : /* Palabras reservadas */
{
  < tPROGRAMA : "programa" >
| < tFINPROGRAMA : "finprograma" >
| < tVAR : "var" >
| < tAND : "and" >
| < tOR : "or" >
| < tNOT : "not" >
| < tPRINCIPIO : "principio" >
| < tFIN : "fin" >
| < tSI : "si" >
| < tENT : "ent" >
| < tSI_NO : "si_no" >
| < tFSI : "fsi" >
| < tMQ : "mq" >
| < tFMQ : "fmq" >
| < tESCRIBIR : "escribir" >
| < tLEER : "leer" >
| < tMOD : "mod" >
| < tDIV : "div" >
| < tENTERO : "entero" >
| < tBOOLEANO : "booleano" >
| < tCARACTER : "caracter" >
| < tTRUE : "true" >
| < tFALSE : "false" >
| < tENTACAR : "entacar" >
| < tCARAENT : "caraent" >
| < tACCION : "accion" >
| < tVAL : "val" >
| < tREF : "ref" >
| < tMAYOR : ">" >
| < tMENOR : "<" >
| < tIGUAL : "=" >
| < tMAI : ">=" >
| < tMEI : "<=" >
| < tNI : "<>" >
| < tOPAS : ":=" >
| < tALM : "#" >
} SKIP :{  " "| "\r"| "\t"| "\n"
|  <"%" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>					/* Comentario unilinea */
|  <"%%" (~["%"])* "%" ("*" | ~["%","/"] (~["%"])* "%")* "%">   /* Comentario multilinea */}
TOKEN :	/* Identificador */
{
  < tIDENTIFICADOR : ((< tLETRA >|"_")(< tLETRA >|< tNUMERO >| "_")*(< tLETRA > | < tNUMERO >))|(< tLETRA >) >
| < #tLETRA: ["a"-"z"] >
}

TOKEN : /* Caracter */
{
	< tCARAC : < tCOMILLA >(~["\""])< tCOMILLA > >
}

TOKEN : /* Cadena */
{
	< tCADENA : <tCOMILLA >(~["\""])*< tCOMILLA > >
}

TOKEN : /* Palabra */
{
  < tPALABRA : (["a"-"z"])+ >
}
TOKEN : /* OPERATORS */{  < tMAS : "+" >| < tMENOS : "-" >| < tPOR : "*" >| < tDIVISION : "/" >}TOKEN :{  < tNUMERO : (< DIGIT >)+ >| < #DIGIT : [ "0"-"9" ] >}

TOKEN : /* Literales */
{
  < tCOMILLA : "\"" >
| < tPARIZQ : "(" >
| < tPARDER : ")" >
| < tCOMA : "," >
| < tPUNTCOM : ";" >
}

int compile() :
{}
{
  programa()  {    return 0;  }| ("#"
| < EOF >)  {  return 1;
  }
}

/*
* Programa ::= <tPROGRAMA> <tIDENTIFICADOR> ";"
* declaracion_variables declaracion_acciones
* bloque_sentencias
*/
void programa() :
{Token tk;}
{
  < tPROGRAMA >{Constants.numPrograma++;} tk = < tIDENTIFICADOR >
  {Constants.numIdentificador++;}< tPUNTCOM >
  declaracion_variables() declaracion_acciones()
  bloque_sentencias()
  {T.introducir_programa(tk.image,0);}}

/* declaracion_variables ::= ( declaracion ";" )* */
void declaracion_variables() :
{}
{
  ( declaracion() < tPUNTCOM > )*
}

/* declaración ::= tipo_variables identificadores */
void declaracion() :
{ArrayList< Token > ids; Tipo_variable tipVar; }
{
  tipVar = tipo_variables()  ids = identificadores()
  {Constants.numVariables = Constants.numVariables + ids.size();
   for(int i = 0;  i < ids.size(); i++){
     	Simbolo s = T.buscar_simbolo(ids.get(i).image);
     	if((s == null) || (s.getNivel() != nivel)){
   			T.introducir_variable(ids.get(i).image, tipVar, nivel, 0);
  		}
  		else  		{
  		  error_semantico(ids.get(i), "Identificador duplicado");  		}
	 }
  }
}

/*tipo_variables ::= <tENTERO> | <tCARACTER> | <tBOOLEANO> */
Tipo_variable tipo_variables() :
{}
{
  < tENTERO >{Constants.numEntero++; return Tipo_variable.ENTERO;}
| < tCARACTER >{Constants.numCaracter++; return Tipo_variable.CHAR;}
| < tBOOLEANO >{Constants.numBooleano++; return Tipo_variable.BOOLEANO;}
{}
}

/*identificadores ::= <tIDENTIFICADOR> ( "," <tIDENTIFICADOR> )* */
ArrayList< Token > identificadores() :
{ArrayList< Token > ids = new ArrayList< Token >(); Token tk;}
{
  tk = < tIDENTIFICADOR >{ids.add(tk); Constants.numIdentificador++;}
  ( "," tk = <tIDENTIFICADOR >{ids.add(tk); Constants.numIdentificador++;} )*
  {return ids;}
}

/*declaracion_acciones ::= ( declaracion_accion )* */
void declaracion_acciones() :
{}
{
  ( declaracion_accion() )*
}

/* declaracion_accion ::= cabecera_accion ";"
 * declaracion_variables declaracion_acciones bloque_sentencias
 */
void declaracion_accion() :
{}
{  cabecera_accion() < tPUNTCOM >
  declaracion_variables() declaracion_acciones() bloque_sentencias()
  {Constants.numAcciones++;
   T.eliminar_variables(nivel);
   T.eliminar_acciones(nivel);
   nivel--;}}

/* cabecera_accion ::= <tACCION> <tIDENTIFICADOR> parametros_formales */
void cabecera_accion() :
{ArrayList<Simbolo> listaParam; Token tk;}
{
  < tACCION >{Constants.numAccion++;} tk = < tIDENTIFICADOR >
  {Constants.numIdentificador++; nivel++;} listaParam = parametros_formales()
  {
    Simbolo s = T.buscar_simbolo(tk.image);
    if((s == null) || (s.getNivel() != nivel-1)){
   		T.introducir_accion(tk.image, nivel-1, 0, listaParam);
  	}
  	else
  	{
  	  error_semantico(tk, "Identificador duplicado");
  	}
  }
}

/* parametros_formales ::= ( "(" ( parametros ( ";" parametros )* )* ")" )? */
ArrayList< Simbolo > parametros_formales() :
{ArrayList <Simbolo > params = new ArrayList<Simbolo >(); ArrayList<Simbolo > aux;}
{
  ( < tPARIZQ >{Constants.numPariz++;}( aux = parametros()  {params.addAll(aux);}
  ( ";" aux = parametros(){params.addAll(aux);} )* )*< tPARDER >{Constants.numParder++;} )?
  {return params;}
}

/*lista_parametros ::= identificadores */
ArrayList< Token > lista_parametros() :
{ArrayList< Token > ids;}
{  ids = identificadores()
  {return ids;}
}

/* parámetros ::= clase_parametros tipo_variables lista_parametros */
ArrayList <Simbolo > parametros() :
{ArrayList< Token > ids; ArrayList<Simbolo > params; Clase_parametro p; Tipo_variable v;}
{
  p = clase_parametros() v = tipo_variables() ids = lista_parametros()
  {Constants.numParametros = Constants.numParametros + ids.size();
	params = new ArrayList<Simbolo >(); 
	for(int i = 0; i < ids.size(); i++){
	  Simbolo s = T.buscar_simbolo(ids.get(i).image);
   	  if((s == null) || (s.getNivel() != nivel)){
   		Simbolo s1 = new Simbolo();
		s1.introducir_parametro(ids.get(i).image, v, p, nivel);
		params.add(s1);
		T.introducir_parametro(ids.get(i).image, v, p, nivel, 0);
  	  }
  	  else
  	  {
  	    error_semantico(ids.get(i), "Identificador duplicado");
  	  }		
	}
	return params;
  }
}

/* clase_parametros ::= <tVAL> | <tREF> */
Clase_parametro clase_parametros() :
{}
{  < tVAL >{Constants.numVal++; return Clase_parametro.VAL;}
| < tREF >{Constants.numRef++; return Clase_parametro.REF;}
}
/* bloque_sentencias ::= <tPRINCIPIO> lista_sentencias <tFIN> */
void bloque_sentencias() :
{}
{
  < tPRINCIPIO >{Constants.numPrincipio++;} lista_sentencias()
   < tFIN >{Constants.numFin++; T.mostrar_tabla();}
}

/*lista_sentencias ::= ( sentencia )+ */
void lista_sentencias() :
{}
{
  ( sentencia() )+
}

/*
* sentencia ::= leer ";"
*| escribir ";"
*| < tIDENTIFICADOR > asig_o_inv
*| selección
*| mientras_que
*/
void sentencia() :
{Token tk;}
{
  leer() < tPUNTCOM >
| escribir() < tPUNTCOM >
| tk = < tIDENTIFICADOR >{Constants.numIdentificador++;
							Simbolo s = T.buscar_simbolo(tk.image);
							if(s !=null && s.es_valor())							{
							  error_semantico(tk, "Argumento por valor y no por referencia");							}
} asig_o_inv()
| seleccion()
| mientras_que()
}

/*leer ::= <tLEER> "(" lista_asignables ")" */
void leer() :
{ArrayList<Token > ids;}
{
  < tLEER >{Constants.numLeer++;} < tPARIZQ >{Constants.numPariz++;}
   ids = lista_asignables() < tPARDER >{Constants.numParder++;}
   {for(int i = 0; i < ids.size(); i++){   		Simbolo s = T.buscar_simbolo(ids.get(i).image);
   		if(s.es_valor())   		{			error_semantico(ids.get(i), "Argumento por valor y no por referencia");
   		}   }
 }
}
/*lista_asignables ::= identificadores */
ArrayList<Token > lista_asignables() :
{ArrayList<Token > ids;}
{
  ids = identificadores()
  {return ids;}
}

/*escribir ::= <tESCRIBIR> "(" lista_escribibles ")" */
void escribir() :
{}
{
  < tESCRIBIR >{Constants.numEscribir++;} < tPARIZQ >{Constants.numPariz++;}
   lista_escribibles() < tPARDER >{Constants.numParder++;}
  {Constants.numOpEscribir++;}
}

/*lista_escribibles ::= (expresion | cadena) ( "," (expresion | cadena) )* */
void lista_escribibles() :
{}
{
  (expresion() | cadena()) ( "," (expresion() | cadena()) )*
}

/*asig_o_inv ::= asignación | invocacion_accion*/
void asig_o_inv() :
{}
{
  asignacion()
| invocacion_accion()
}

/*asignación ::= <tOPAS> expresion ";" */
void asignacion() :
{}
{
  <tOPAS >{Constants.numOpas++;} expresion() < tPUNTCOM >
  {Constants.numAsignar++;}
}

/*invocacion_accion ::= argumentos ";" */
void invocacion_accion() :
{}
{
  argumentos() < tPUNTCOM >
  {Constants.numInvocar++;}
}

/*mientras_que ::= <tMQ> expresión lista_sentencias <tFMQ> */
void mientras_que() :
{}
{
  < tMQ >{Constants.numMQ++;} expresion() lista_sentencias() < tFMQ >
  {Constants.numFMQ++;}
  {Constants.numBucles++;}
}

/*selección ::= < tSI > "(" expresion ")" < tENT > lista_sentencias ( < tSI_NO > lista_sentencias )?  < tFSI > */
void seleccion() :
{}
{
  < tSI >{Constants.numSi++;} expresion() < tENT > lista_sentencias()
  ( < tSI_NO >{Constants.numSi_No++;} lista_sentencias() )? < tFSI >
  {Constants.numFSI++;}
  {Constants.numif++;}
}

/*argumentos ::= ( "(" ( lista_expresiones )? ")" )? */
void argumentos() :
{}
{
  (< tPARIZQ >{Constants.numPariz++;} ( lista_expresiones() )? < tPARDER >
  {Constants.numParder++;})?
}

/*lista_expresiones ::= expresión ( "," expresión )* */
void lista_expresiones() :
{}
{
  expresion() ( "," expresion() )*
}

/*expresión ::= expresion_simple ( operador_relacional expresion_simple)? */
void expresion() :
{}
{
  expresion_simple() ( operador_relacional() expresion_simple() )?
  {Constants.numExpresiones++;} 
}

/*
*operador_relacional ::= < tMAYOR >
*| < tMENOR >
*| < tIGUAL >
*| < tMAI >
*| < tMEI >
*| < tNI >
*/
void operador_relacional() :
{}
{
  (< tMAYOR >{Constants.numMayor++;}
| < tMENOR >{Constants.numMenor++;}
| < tIGUAL >{Constants.numIgual++;}
| < tMAI >{Constants.numMai++;}
| < tMEI >{Constants.numMei++;}
| < tNI >{Constants.numNi++;})
	{Constants.numOpRel++;}
}

/*expresion_simple ::= termino ( operador_aditivo termino )* */
void expresion_simple() :
{}
{
  termino() ( operador_aditivo() termino() )*
  {Constants.numExpresionesS++;}
}

/* operador_aditivo ::= < tMAS >
 *| < tMENOS >
 *| < tOR >
 */
void operador_aditivo() :
{}
{
  (< tMAS >{Constants.numMas++;}
| < tMENOS >{Constants.numMenos++;}
| < tOR >{Constants.numOr++;})
{Constants.numOpAdd++;}
}

/*termino ::= factor ( operador_multiplicativo factor )* */
void termino() :
{}
{
  factor() ( operador_multiplicativo() factor() )*
  {Constants.numTermino++;}
}

/* operador_multiplicativo ::= < tPOR >
 *| < tDIVISION >
 *| < tAND >
 *| < tMOD >
 *| < tDIV >
 */
void operador_multiplicativo() :
{}
{
  (< tPOR >{Constants.numPor++;}
| < tDIVISION >{Constants.numDivision++;}
| < tAND >{Constants.numAnd++;}
| < tMOD >{Constants.numMod++;}
| < tDIV >{Constants.numDiv++;})
{Constants.numOpMul++;}
}

/*
 *factor ::= "-" factor
 *| <tNOT> factor
 *| "(" expresion ")"
 *| <tENTACAR> "(" expresion ")"
 *| <tCARAENT> "(" expresion ")"
 *| <tIDENTIFICADOR>
 *| <tCONSTENTERA>
 *| <tCONSTCHAR>
 *| <tTRUE>
 *| <tFALSE>
 */
Token factor() :
{Token tk = null;}
{
  (    "-" factor()
|< tNOT >{Constants.numNot++;} tk = factor()
|< tENTACAR >{Constants.numEntacar++;} < tPARIZQ >{Constants.numPariz++;}
expresion() < tPARDER >{Constants.numParder++;}
|< tCARAENT >{Constants.numCaraent++;} < tPARIZQ >{Constants.numPariz++;}
 expresion() < tPARDER >{Constants.numParder++;}
|tk = < tIDENTIFICADOR >{Constants.numIdentificador++;}
|< tNUMERO >{Constants.numNumero++;}
|< tCARAC >{Constants.numCarac++;}
|< tTRUE >{Constants.numTrue++; }
|< tFALSE >{Constants.numFalse++;}
|< tPARIZQ >{Constants.numPariz++;} expresion() < tPARDER >{Constants.numParder++;})
{Constants.numFactor++; return tk;}
}

/* cadena ::= < tCADENA > */
void cadena() :
{}
{	< tCADENA >{Constants.numCadena++;}}

